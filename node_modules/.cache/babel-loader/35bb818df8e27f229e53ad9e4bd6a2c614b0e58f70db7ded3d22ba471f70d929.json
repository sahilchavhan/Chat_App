{"ast":null,"code":"// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor(options) {\n    let maxLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = options.longWordSplit.wrapCharacters || [];\n    this.forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   */\n  pushWord(word) {\n    if (this.nextLineAvailableChars <= 0) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if (cost <= this.nextLineAvailableChars) {\n      // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n    } else {\n      // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) {\n        this.startNewLine();\n      }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord() {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   */\n  concatWord(word) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord(lastWord ? lastWord.concat(word) : word);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({\n        length: n - 1\n      }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty() {\n    return this.lines.length === 0 && this.nextLineWords.length === 0;\n  }\n  clear() {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return [...this.lines, this.nextLineWords].map(words => words.join(' ')).join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord(word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n      if (splitIndex > -1) {\n        // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n      } else {\n        // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) {\n          // There is next character to try\n\n          word = firstLine + remainingChars;\n        } else {\n          // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n        }\n      }\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\nmodule.exports = {\n  InlineTextBuilder: InlineTextBuilder\n};","map":{"version":3,"names":["require","InlineTextBuilder","constructor","options","maxLineLength","undefined","lines","nextLineWords","wordwrap","Number","MAX_VALUE","nextLineAvailableChars","wrapCharacters","longWordSplit","forceWrapOnLimit","stashedSpace","wordBreakOpportunity","pushWord","word","startNewLine","isLineStart","length","cost","push","first","rest","splitLongWord","part","popWord","lastWord","pop","concatWord","concat","n","Array","from","isEmpty","clear","toString","map","words","join","parts","idx","firstLine","substring","remainingChars","splitIndex","lastIndexOf","module","exports"],"sources":["C:/Users/Tapasya/Desktop/SAHIL VIT/chatapp/node_modules/html-to-text/lib/inline-text-builder.js"],"sourcesContent":["// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Helps to build text from words.\n */\nclass InlineTextBuilder {\n  /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */\n  constructor (options, maxLineLength = undefined) {\n    /** @type { string[][] } */\n    this.lines = [];\n    /** @type { string[] }   */\n    this.nextLineWords = [];\n    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n    this.nextLineAvailableChars = this.maxLineLength;\n    this.wrapCharacters = options.longWordSplit.wrapCharacters || [];\n    this.forceWrapOnLimit = options.longWordSplit.forceWrapOnLimit || false;\n\n    this.stashedSpace = false;\n    this.wordBreakOpportunity = false;\n  }\n\n  /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   */\n  pushWord (word) {\n    if (this.nextLineAvailableChars <= 0) {\n      this.startNewLine();\n    }\n    const isLineStart = this.nextLineWords.length === 0;\n    const cost = word.length + (isLineStart ? 0 : 1);\n    if (cost <= this.nextLineAvailableChars) { // Fits into available budget\n\n      this.nextLineWords.push(word);\n      this.nextLineAvailableChars -= cost;\n\n    } else { // Does not fit - try to split the word\n\n      // The word is moved to a new line - prefer to wrap between words.\n      const [first, ...rest] = this.splitLongWord(word);\n      if (!isLineStart) { this.startNewLine(); }\n      this.nextLineWords.push(first);\n      this.nextLineAvailableChars -= first.length;\n      for (const part of rest) {\n        this.startNewLine();\n        this.nextLineWords.push(part);\n        this.nextLineAvailableChars -= part.length;\n      }\n\n    }\n  }\n\n  /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */\n  popWord () {\n    const lastWord = this.nextLineWords.pop();\n    if (lastWord !== undefined) {\n      const isLineStart = this.nextLineWords.length === 0;\n      const cost = lastWord.length + (isLineStart ? 0 : 1);\n      this.nextLineAvailableChars += cost;\n    }\n    return lastWord;\n  }\n\n  /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   */\n  concatWord (word) {\n    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n      this.pushWord(word);\n      this.wordBreakOpportunity = false;\n    } else {\n      const lastWord = this.popWord();\n      this.pushWord((lastWord) ? lastWord.concat(word) : word);\n    }\n  }\n\n  /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */\n  startNewLine (n = 1) {\n    this.lines.push(this.nextLineWords);\n    if (n > 1) {\n      this.lines.push(...Array.from({ length: n - 1 }, () => []));\n    }\n    this.nextLineWords = [];\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */\n  isEmpty () {\n    return this.lines.length === 0\n        && this.nextLineWords.length === 0;\n  }\n\n  clear () {\n    this.lines.length = 0;\n    this.nextLineWords.length = 0;\n    this.nextLineAvailableChars = this.maxLineLength;\n  }\n\n  /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return [...this.lines, this.nextLineWords]\n      .map(words => words.join(' '))\n      .join('\\n');\n  }\n\n  /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */\n  splitLongWord (word) {\n    const parts = [];\n    let idx = 0;\n    while (word.length > this.maxLineLength) {\n\n      const firstLine = word.substring(0, this.maxLineLength);\n      const remainingChars = word.substring(this.maxLineLength);\n\n      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n\n      if (splitIndex > -1) { // Found a character to split on\n\n        word = firstLine.substring(splitIndex + 1) + remainingChars;\n        parts.push(firstLine.substring(0, splitIndex + 1));\n\n      } else { // Not found a character to split on\n\n        idx++;\n        if (idx < this.wrapCharacters.length) { // There is next character to try\n\n          word = firstLine + remainingChars;\n\n        } else { // No more characters to try\n\n          if (this.forceWrapOnLimit) {\n            parts.push(firstLine);\n            word = remainingChars;\n            if (word.length > this.maxLineLength) {\n              continue;\n            }\n          } else {\n            word = firstLine + remainingChars;\n          }\n          break;\n\n        }\n\n      }\n\n    }\n    parts.push(word); // Add remaining part to array\n    return parts;\n  }\n}\n\nmodule.exports = { InlineTextBuilder: InlineTextBuilder };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}