{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n  if (!Array.isArray(node)) node = [node];\n  return find(test, node, recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n  var result = [];\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var elem = nodes_1[_i];\n    if (test(elem)) {\n      result.push(elem);\n      if (--limit <= 0) break;\n    }\n    if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n      var children = find(test, elem.children, recurse, limit);\n      result.push.apply(result, children);\n      limit -= children.length;\n      if (limit <= 0) break;\n    }\n  }\n  return result;\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n */\nfunction findOneChild(test, nodes) {\n  return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first child node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n  var elem = null;\n  for (var i = 0; i < nodes.length && !elem; i++) {\n    var checked = nodes[i];\n    if (!(0, domhandler_1.isTag)(checked)) {\n      continue;\n    } else if (test(checked)) {\n      elem = checked;\n    } else if (recurse && checked.children.length > 0) {\n      elem = findOne(test, checked.children);\n    }\n  }\n  return elem;\n}\nexports.findOne = findOne;\n/**\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing a test.\n */\nfunction existsOne(test, nodes) {\n  return nodes.some(function (checked) {\n    return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));\n  });\n}\nexports.existsOne = existsOne;\n/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n  var _a;\n  var result = [];\n  var stack = nodes.filter(domhandler_1.isTag);\n  var elem;\n  while (elem = stack.shift()) {\n    var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);\n    if (children && children.length > 0) {\n      stack.unshift.apply(stack, children);\n    }\n    if (test(elem)) result.push(elem);\n  }\n  return result;\n}\nexports.findAll = findAll;","map":{"version":3,"names":["Object","defineProperty","exports","value","findAll","existsOne","findOne","findOneChild","find","filter","domhandler_1","require","test","node","recurse","limit","Infinity","Array","isArray","nodes","result","_i","nodes_1","length","elem","push","hasChildren","children","apply","i","checked","isTag","some","_a","stack","shift","unshift"],"sources":["C:/Users/Tapasya/Desktop/SAHIL VIT/chatapp/node_modules/domutils/lib/querying.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    if (!Array.isArray(node))\n        node = [node];\n    return find(test, node, recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var elem = nodes_1[_i];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                break;\n        }\n        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n            var children = find(test, elem.children, recurse, limit);\n            result.push.apply(result, children);\n            limit -= children.length;\n            if (limit <= 0)\n                break;\n        }\n    }\n    return result;\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first child node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var checked = nodes[i];\n        if (!(0, domhandler_1.isTag)(checked)) {\n            continue;\n        }\n        else if (test(checked)) {\n            elem = checked;\n        }\n        else if (recurse && checked.children.length > 0) {\n            elem = findOne(test, checked.children);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing a test.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return (0, domhandler_1.isTag)(checked) &&\n            (test(checked) ||\n                (checked.children.length > 0 &&\n                    existsOne(test, checked.children)));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n    var _a;\n    var result = [];\n    var stack = nodes.filter(domhandler_1.isTag);\n    var elem;\n    while ((elem = stack.shift())) {\n        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);\n        if (children && children.length > 0) {\n            stack.unshift.apply(stack, children);\n        }\n        if (test(elem))\n            result.push(elem);\n    }\n    return result;\n}\nexports.findAll = findAll;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}