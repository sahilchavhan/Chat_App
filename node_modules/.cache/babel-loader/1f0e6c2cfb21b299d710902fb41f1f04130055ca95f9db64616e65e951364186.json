{"ast":null,"code":"const {\n  trimCharacter\n} = require('./helper');\n// eslint-disable-next-line no-unused-vars\nconst {\n  StackItem,\n  BlockStackItem,\n  TableCellStackItem,\n  TableRowStackItem,\n  TableStackItem,\n  TransformerStackItem\n} = require('./stack-item');\nconst {\n  tableToString\n} = require('./table-printer');\nconst {\n  WhitespaceProcessor\n} = require('./whitespace-processor');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  constructor(options) {\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform(wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform() {\n    if (!this._wordTransformer) {\n      return undefined;\n    }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer() {\n    const applyTransformer = (str, transformer) => transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n    return str => applyTransformer(str, this._wordTransformer);\n  }\n  _popStackItem() {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak() {\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity() {\n    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n  addInline(str) {\n    let optionsObjectOrNoWordTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, {\n        noWordTransform: optionsObjectOrNoWordTransform\n      });\n    }\n  }\n  _addInline(str) {\n    let {\n      noWordTransform = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof TableCellStackItem)) {\n      return;\n    }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n    if (this.whitepaceProcessor.testContainsWords(str) ||\n    // There are words to add;\n    str.length && !this._stackItem.stashedLineBreaks // or at least spaces to take into account.\n    ) {\n      if (this._stackItem.stashedLineBreaks) {\n        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n      }\n      this.whitepaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, this._wordTransformer && !noWordTransform ? this._getCombinedWordTransformer() : undefined);\n      this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n  openBlock() {\n    let optionsObjectOrLeadingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let reservedLineLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let isPre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength\n      });\n    }\n  }\n  _openBlock() {\n    let {\n      leadingLineBreaks = 1,\n      reservedLineLength = 0,\n      isPre = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n    if (isPre) {\n      this._stackItem.isPre = true;\n    }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n  closeBlock() {\n    let optionsObjectOrTrailingLineBreaks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let blockTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform\n      });\n    }\n  }\n  _closeBlock() {\n    let {\n      trailingLineBreaks = 1,\n      blockTransform = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const block = this._popStackItem();\n    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable() {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow() {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell() {\n    let optionsObjectOrMaxColumnWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({\n        maxColumnWidth: optionsObjectOrMaxColumnWidth\n      });\n    }\n  }\n  _openTableCell() {\n    let {\n      maxColumnWidth = undefined\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n  closeTableCell() {\n    let optionsObjectOrColspan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let rowspan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan\n      });\n    }\n  }\n  _closeTableCell() {\n    let {\n      colspan = 1,\n      rowspan = 1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({\n      colspan: colspan,\n      rowspan: rowspan,\n      text: text\n    });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow() {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is depreceted.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n  closeTable() {\n    let optionsObjectOrColSpacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let rowSpacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let leadingLineBreaks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let trailingLineBreaks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n  _closeTable() {\n    let {\n      colSpacing = 3,\n      rowSpacing = 0,\n      leadingLineBreaks = 2,\n      trailingLineBreaks = 2\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const table = this._popStackItem();\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString() {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n}\n\nfunction getText(stackItem) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(stackItem instanceof BlockStackItem || stackItem instanceof TableCellStackItem)) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\nmodule.exports = {\n  BlockTextBuilder: BlockTextBuilder\n};","map":{"version":3,"names":["trimCharacter","require","StackItem","BlockStackItem","TableCellStackItem","TableRowStackItem","TableStackItem","TransformerStackItem","tableToString","WhitespaceProcessor","BlockTextBuilder","constructor","options","whitepaceProcessor","_stackItem","_wordTransformer","undefined","pushWordTransform","wordTransform","popWordTransform","transform","next","_getCombinedWordTransformer","applyTransformer","str","transformer","_popStackItem","item","addLineBreak","isPre","rawText","inlineTextBuilder","startNewLine","addWordBreakOpportunity","wordBreakOpportunity","addInline","optionsObjectOrNoWordTransform","_addInline","noWordTransform","testContainsWords","length","stashedLineBreaks","shrinkWrapAdd","openBlock","optionsObjectOrLeadingLineBreaks","reservedLineLength","_openBlock","leadingLineBreaks","maxLineLength","Math","max","closeBlock","optionsObjectOrTrailingLineBreaks","blockTransform","_closeBlock","trailingLineBreaks","block","blockText","getText","addText","openTable","openTableRow","Error","openTableCell","optionsObjectOrMaxColumnWidth","_openTableCell","maxColumnWidth","closeTableCell","optionsObjectOrColspan","rowspan","_closeTableCell","colspan","cell","text","cells","push","closeTableRow","row","rows","closeTable","optionsObjectOrColSpacing","rowSpacing","_closeTable","colSpacing","table","output","toString","getRoot","stackItem","isEmpty","parentText","lineBreaks","clear","repeat","module","exports"],"sources":["C:/Users/AVITA/Desktop/chatbot/node_modules/html-to-text/lib/block-text-builder.js"],"sourcesContent":["\nconst { trimCharacter } = require('./helper');\n// eslint-disable-next-line no-unused-vars\nconst { StackItem, BlockStackItem, TableCellStackItem, TableRowStackItem, TableStackItem, TransformerStackItem }\n  = require('./stack-item');\nconst { tableToString } = require('./table-printer');\nconst { WhitespaceProcessor } = require('./whitespace-processor');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */\nclass BlockTextBuilder {\n\n  /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   */\n  constructor (options) {\n    this.options = options;\n    this.whitepaceProcessor = new WhitespaceProcessor(options);\n    /** @type { StackItem } */\n    this._stackItem = new BlockStackItem(options);\n    /** @type { TransformerStackItem } */\n    this._wordTransformer = undefined;\n  }\n\n  /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */\n  pushWordTransform (wordTransform) {\n    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n  }\n\n  /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */\n  popWordTransform () {\n    if (!this._wordTransformer) { return undefined; }\n    const transform = this._wordTransformer.transform;\n    this._wordTransformer = this._wordTransformer.next;\n    return transform;\n  }\n\n  /** @returns { (str: string) => string } */\n  _getCombinedWordTransformer () {\n    const applyTransformer = (str, transformer) =>\n      ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);\n    return (str) => applyTransformer(str, this._wordTransformer);\n  }\n\n  _popStackItem () {\n    const item = this._stackItem;\n    this._stackItem = item.next;\n    return item;\n  }\n\n  /**\n   * Add a line break into currently built block.\n   */\n  addLineBreak () {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += '\\n';\n    } else {\n      this._stackItem.inlineTextBuilder.startNewLine();\n    }\n  }\n\n  /**\n   * Allow to break line in case directly following text will not fit.\n   */\n  addWordBreakOpportunity () {\n    if (\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    ) {\n      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n    }\n  }\n\n  /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object | boolean } [ optionsObjectOrNoWordTransform ]\n   * Object holding the parameters of the operation.\n   *\n   * Boolean value is deprecated.\n   *\n   * @param { boolean } [ optionsObjectOrNoWordTransform.noWordTransform = false ]\n   * Ignore word transformers if there are any.\n   */\n  addInline (str, optionsObjectOrNoWordTransform = {}) {\n    if (typeof optionsObjectOrNoWordTransform === 'object') {\n      this._addInline(str, optionsObjectOrNoWordTransform);\n    } else {\n      this._addInline(str, { noWordTransform: optionsObjectOrNoWordTransform });\n    }\n  }\n\n  _addInline (str, { noWordTransform = false } = {}) {\n    if (!(\n      this._stackItem instanceof BlockStackItem\n      || this._stackItem instanceof TableCellStackItem\n    )) { return; }\n\n    if (this._stackItem.isPre) {\n      this._stackItem.rawText += str;\n      return;\n    }\n\n    if (\n      this.whitepaceProcessor.testContainsWords(str) || // There are words to add;\n      (str.length && !this._stackItem.stashedLineBreaks) // or at least spaces to take into account.\n    ) {\n      if (this._stackItem.stashedLineBreaks) {\n        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n      }\n      this.whitepaceProcessor.shrinkWrapAdd(\n        str,\n        this._stackItem.inlineTextBuilder,\n        (this._wordTransformer && !noWordTransform) ? this._getCombinedWordTransformer() : undefined\n      );\n      this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n  }\n\n  /**\n   * Start building a new block.\n   *\n   * @param { object | number } [optionsObjectOrLeadingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.leadingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number }  [optionsObjectOrLeadingLineBreaks.reservedLineLength = 0]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [optionsObjectOrLeadingLineBreaks.isPre = false]\n   * Should HTML whitespace be preserved inside this block.\n   *\n   * @param { number }  [reservedLineLength]\n   * Deprecated.\n   *\n   * @param { boolean } [isPre]\n   * Deprecated.\n   */\n  openBlock (optionsObjectOrLeadingLineBreaks = {}, reservedLineLength = undefined, isPre = undefined) {\n    if (typeof optionsObjectOrLeadingLineBreaks === 'object') {\n      this._openBlock(optionsObjectOrLeadingLineBreaks);\n    } else {\n      this._openBlock({\n        isPre: isPre,\n        leadingLineBreaks: optionsObjectOrLeadingLineBreaks,\n        reservedLineLength: reservedLineLength,\n      });\n    }\n  }\n\n  _openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n    this._stackItem = new BlockStackItem(\n      this.options,\n      this._stackItem,\n      leadingLineBreaks,\n      maxLineLength\n    );\n    if (isPre) { this._stackItem.isPre = true; }\n  }\n\n  /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object | number }         [optionsObjectOrTrailingLineBreaks]\n   * Object holding the parameters of the block.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number }                  [optionsObjectOrTrailingLineBreaks.trailingLineBreaks = 1]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [optionsObjectOrTrailingLineBreaks.blockTransform = undefined]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   *\n   * @param { (str: string) => string } [blockTransform]\n   * Deprecated.\n   */\n  closeBlock (optionsObjectOrTrailingLineBreaks = {}, blockTransform = undefined) {\n    if (typeof optionsObjectOrTrailingLineBreaks === 'object') {\n      this._closeBlock(optionsObjectOrTrailingLineBreaks);\n    } else {\n      this._closeBlock({\n        trailingLineBreaks: optionsObjectOrTrailingLineBreaks,\n        blockTransform: blockTransform,\n      });\n    }\n  }\n\n  _closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n    const block = this._popStackItem();\n    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);\n    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n  }\n\n  /**\n   * Start building a table.\n   */\n  openTable () {\n    this._stackItem = new TableStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table row.\n   */\n  openTableRow () {\n    if (!(this._stackItem instanceof TableStackItem)) {\n      throw new Error('Can\\'t add table row to something that is not a table! Check the formatter.');\n    }\n    this._stackItem = new TableRowStackItem(this._stackItem);\n  }\n\n  /**\n   * Start building a table cell.\n   *\n   * @param { object | number } [optionsObjectOrMaxColumnWidth = undefined]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrMaxColumnWidth.maxColumnWidth = undefined]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */\n  openTableCell (optionsObjectOrMaxColumnWidth = {}) {\n    if (typeof optionsObjectOrMaxColumnWidth === 'object') {\n      this._openTableCell(optionsObjectOrMaxColumnWidth);\n    } else {\n      this._openTableCell({ maxColumnWidth: optionsObjectOrMaxColumnWidth });\n    }\n  }\n\n  _openTableCell ({ maxColumnWidth = undefined } = {}) {\n    if (!(this._stackItem instanceof TableRowStackItem)) {\n      throw new Error('Can\\'t add table cell to something that is not a table row! Check the formatter.');\n    }\n    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n  }\n\n  /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object | number } [optionsObjectOrColspan]\n   * Object holding the parameters of the cell.\n   *\n   * Number value is deprecated.\n   *\n   * @param { number } [optionsObjectOrColspan.colspan = 1] How many columns this cell should occupy.\n   * @param { number } [optionsObjectOrColspan.rowspan = 1] How many rows this cell should occupy.\n   *\n   * @param { number } [rowspan] Deprecated.\n   */\n  closeTableCell (optionsObjectOrColspan = {}, rowspan = undefined) {\n    if (typeof optionsObjectOrColspan === 'object') {\n      this._closeTableCell(optionsObjectOrColspan);\n    } else {\n      this._closeTableCell({\n        colspan: optionsObjectOrColspan,\n        rowspan: rowspan,\n      });\n    }\n  }\n\n  _closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {\n    const cell = this._popStackItem();\n    const text = trimCharacter(getText(cell), '\\n');\n    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });\n  }\n\n  /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */\n  closeTableRow () {\n    const row = this._popStackItem();\n    row.next.rows.push(row.cells);\n  }\n\n  /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object | number } [optionsObjectOrColSpacing]\n   * Object holding the parameters of the table.\n   *\n   * Number value is depreceted.\n   *\n   * @param { number } [optionsObjectOrColSpacing.colSpacing = 3]\n   * Number of spaces between table columns.\n   *\n   * @param { number } [optionsObjectOrColSpacing.rowSpacing = 0]\n   * Number of empty lines between table rows.\n   *\n   * @param { number } [optionsObjectOrColSpacing.leadingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [optionsObjectOrColSpacing.trailingLineBreaks = 2]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { number } [rowSpacing]\n   * Deprecated.\n   *\n   * @param { number } [leadingLineBreaks]\n   * Deprecated.\n   *\n   * @param { number } [trailingLineBreaks]\n   * Deprecated.\n   */\n  closeTable (\n    optionsObjectOrColSpacing = {},\n    rowSpacing = undefined,\n    leadingLineBreaks = undefined,\n    trailingLineBreaks = undefined\n  ) {\n    if (typeof optionsObjectOrColSpacing === 'object') {\n      this._closeTable(optionsObjectOrColSpacing);\n    } else {\n      this._closeTable({\n        colSpacing: optionsObjectOrColSpacing,\n        leadingLineBreaks: leadingLineBreaks,\n        rowSpacing: rowSpacing,\n        trailingLineBreaks: trailingLineBreaks\n      });\n    }\n  }\n\n  _closeTable ({ colSpacing = 3, rowSpacing = 0, leadingLineBreaks = 2, trailingLineBreaks = 2 } = {}) {\n    const table = this._popStackItem();\n    const output = tableToString(table.rows, rowSpacing, colSpacing);\n    if (output) {\n      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n    }\n  }\n\n  /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */\n  toString () {\n    return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n  }\n\n}\n\nfunction getText (stackItem) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can be requested for text contents.');\n  }\n  return (stackItem.inlineTextBuilder.isEmpty())\n    ? stackItem.rawText\n    : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\n\nfunction addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n  if (!(\n    stackItem instanceof BlockStackItem\n    || stackItem instanceof TableCellStackItem\n  )) {\n    throw new Error('Only blocks and table cells can contain text.');\n  }\n  const parentText = getText(stackItem);\n  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n  stackItem.inlineTextBuilder.clear();\n  if (parentText) {\n    stackItem.rawText = parentText + '\\n'.repeat(lineBreaks) + text;\n  } else {\n    stackItem.rawText = text;\n    stackItem.leadingLineBreaks = lineBreaks;\n  }\n  stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n\nmodule.exports = { BlockTextBuilder: BlockTextBuilder };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}