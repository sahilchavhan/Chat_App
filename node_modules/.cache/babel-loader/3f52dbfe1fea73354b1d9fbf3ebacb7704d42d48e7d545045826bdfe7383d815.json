{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nfunction removeSubsets(nodes) {\n  var idx = nodes.length;\n  /*\n   * Check if each node (or one of its ancestors) is already contained in the\n   * array.\n   */\n  while (--idx >= 0) {\n    var node = nodes[idx];\n    /*\n     * Remove the node if it is not unique.\n     * We are going through the array from the end, so we only\n     * have to check nodes that preceed the node under consideration in the array.\n     */\n    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n      nodes.splice(idx, 1);\n      continue;\n    }\n    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n      if (nodes.includes(ancestor)) {\n        nodes.splice(idx, 1);\n        break;\n      }\n    }\n  }\n  return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n  var aParents = [];\n  var bParents = [];\n  if (nodeA === nodeB) {\n    return 0;\n  }\n  var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n  while (current) {\n    aParents.unshift(current);\n    current = current.parent;\n  }\n  current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n  while (current) {\n    bParents.unshift(current);\n    current = current.parent;\n  }\n  var maxIdx = Math.min(aParents.length, bParents.length);\n  var idx = 0;\n  while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n    idx++;\n  }\n  if (idx === 0) {\n    return 1 /* DISCONNECTED */;\n  }\n\n  var sharedParent = aParents[idx - 1];\n  var siblings = sharedParent.children;\n  var aSibling = aParents[idx];\n  var bSibling = bParents[idx];\n  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n    if (sharedParent === nodeB) {\n      return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;\n    }\n\n    return 4 /* FOLLOWING */;\n  }\n\n  if (sharedParent === nodeA) {\n    return 2 /* PRECEDING */ | 8 /* CONTAINS */;\n  }\n\n  return 2 /* PRECEDING */;\n}\n\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n  nodes = nodes.filter(function (node, i, arr) {\n    return !arr.includes(node, i + 1);\n  });\n  nodes.sort(function (a, b) {\n    var relative = compareDocumentPosition(a, b);\n    if (relative & 2 /* PRECEDING */) {\n      return -1;\n    } else if (relative & 4 /* FOLLOWING */) {\n      return 1;\n    }\n    return 0;\n  });\n  return nodes;\n}\nexports.uniqueSort = uniqueSort;","map":{"version":3,"names":["Object","defineProperty","exports","value","uniqueSort","compareDocumentPosition","removeSubsets","domhandler_1","require","nodes","idx","length","node","lastIndexOf","splice","ancestor","parent","includes","nodeA","nodeB","aParents","bParents","current","hasChildren","unshift","maxIdx","Math","min","sharedParent","siblings","children","aSibling","bSibling","indexOf","filter","i","arr","sort","a","b","relative"],"sources":["C:/Users/AVITA/Desktop/chatapp/node_modules/domutils/lib/helpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var maxIdx = Math.min(aParents.length, bParents.length);\n    var idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return 1 /* DISCONNECTED */;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;\n        }\n        return 4 /* FOLLOWING */;\n    }\n    if (sharedParent === nodeA) {\n        return 2 /* PRECEDING */ | 8 /* CONTAINS */;\n    }\n    return 2 /* PRECEDING */;\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & 2 /* PRECEDING */) {\n            return -1;\n        }\n        else if (relative & 4 /* FOLLOWING */) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}