{"ast":null,"code":"function getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n  return matrix[j];\n}\nfunction findFirstVacantIndex(row) {\n  let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  while (row[x]) {\n    x++;\n  }\n  return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n\n/**\n * @typedef { object } TablePrinterCell\n * Cell definition for the table printer.\n *\n * @property { number } colspan Number of columns this cell occupies.\n * @property { number } rowspan Number of rows this cell occupies.\n * @property { string } text Cell contents (pre-wrapped).\n */\n\n/**\n * Render a table into string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = line.length > cellWidth ? line.length : cellWidth;\n        }\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n      y += cell.rowspan;\n    }\n  }\n  return outputLines.join('\\n');\n}\nmodule.exports = {\n  tableToString: tableToString\n};","map":{"version":3,"names":["getRow","matrix","j","findFirstVacantIndex","row","x","transposeInPlace","maxSize","i","rowI","rowJ","temp","putCellIntoLayout","cell","layout","baseRow","baseCol","r","rowspan","layoutRow","c","colspan","updateOffset","offsets","base","span","value","Math","max","tableToString","tableRows","rowSpacing","colSpacing","colNumber","rowNumber","length","rowOffsets","cells","lines","text","split","cellHeight","outputLines","colOffsets","y","rendered","cellWidth","line","lineOffset","padEnd","join","module","exports"],"sources":["C:/Users/AVITA/Desktop/chatapp/node_modules/html-to-text/lib/table-printer.js"],"sourcesContent":["\nfunction getRow (matrix, j) {\n  if (!matrix[j]) { matrix[j] = []; }\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex (row, x = 0) {\n  while (row[x]) { x++; }\n  return x;\n}\n\nfunction transposeInPlace (matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\n\nfunction putCellIntoLayout (cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction updateOffset (offsets, base, span, value) {\n  offsets[base + span] = Math.max(\n    offsets[base + span] || 0,\n    offsets[base] + value\n  );\n}\n\n/**\n * @typedef { object } TablePrinterCell\n * Cell definition for the table printer.\n *\n * @property { number } colspan Number of columns this cell occupies.\n * @property { number } rowspan Number of rows this cell occupies.\n * @property { string } text Cell contents (pre-wrapped).\n */\n\n/**\n * Render a table into string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString (tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);\n\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = (line.length > cellWidth) ? line.length : cellWidth;\n        }\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n      y += cell.rowspan;\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\nmodule.exports = { tableToString: tableToString };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}