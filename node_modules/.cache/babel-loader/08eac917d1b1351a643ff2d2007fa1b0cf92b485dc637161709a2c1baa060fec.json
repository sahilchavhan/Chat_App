{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/Tapasya/Desktop/SAHIL VIT/chatapp/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar he = require('he');\nvar _require = require('./helper'),\n  get = _require.get,\n  numberToLetterSequence = _require.numberToLetterSequence,\n  numberToRoman = _require.numberToRoman,\n  splitClassesAndIds = _require.splitClassesAndIds,\n  trimCharacter = _require.trimCharacter;\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip(elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline(elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak(elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbk` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr(elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(function (str) {\n      return str.toUpperCase();\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote(elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: function blockTransform(str) {\n      return (formatOptions.trimEmptyLines !== false ? trimCharacter(str, '\\n') : str).split('\\n').map(function (line) {\n        return '> ' + line;\n      }).join('\\n');\n    }\n  });\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage(elem, walk, builder, formatOptions) {\n  var attribs = elem.attribs || {};\n  var alt = attribs.alt ? he.decode(attribs.alt, builder.options.decodeOptions) : '';\n  var src = !attribs.src ? '' : formatOptions.baseUrl && attribs.src.indexOf('/') === 0 ? formatOptions.baseUrl + attribs.src : attribs.src;\n  var text = !src ? alt : !alt ? '[' + src + ']' : alt + ' [' + src + ']';\n  builder.addInline(text);\n}\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor(elem, walk, builder, formatOptions) {\n  function getHref() {\n    if (formatOptions.ignoreHref) {\n      return '';\n    }\n    if (!elem.attribs || !elem.attribs.href) {\n      return '';\n    }\n    var href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') {\n      return '';\n    }\n    href = formatOptions.baseUrl && href[0] === '/' ? formatOptions.baseUrl + href : href;\n    return he.decode(href, builder.options.decodeOptions);\n  }\n  var href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    var text = '';\n    builder.pushWordTransform(function (str) {\n      if (str) {\n        text += str;\n      }\n      return str;\n    });\n    walk(elem.children, builder);\n    builder.popWordTransform();\n    var hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(!text ? href : formatOptions.noLinkBrackets ? ' ' + href : ' [' + href + ']', {\n        noWordTransform: true\n      });\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns inreasing index each time it is called.\n */\nfunction formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n  var isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  var maxPrefixLength = 0;\n  var listItems = (elem.children || []\n  // it might be more accuurate to check only for html spaces here, but no significant benefit\n  ).filter(function (child) {\n    return child.type !== 'text' || !/^\\s*$/.test(child.data);\n  }).map(function (child) {\n    if (child.name !== 'li') {\n      return {\n        node: child,\n        prefix: ''\n      };\n    }\n    var prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n    if (prefix.length > maxPrefixLength) {\n      maxPrefixLength = prefix.length;\n    }\n    return {\n      node: child,\n      prefix: prefix\n    };\n  });\n  if (!listItems.length) {\n    return;\n  }\n  var reservedLineLength = maxPrefixLength;\n  var spacing = '\\n' + ' '.repeat(reservedLineLength);\n  builder.openBlock({\n    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2\n  });\n  var _iterator = _createForOfIteratorHelper(listItems),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var _step$value = _step.value,\n        node = _step$value.node,\n        prefix = _step$value.prefix;\n      builder.openBlock({\n        leadingLineBreaks: 1,\n        reservedLineLength: reservedLineLength\n      });\n      walk([node], builder);\n      builder.closeBlock({\n        trailingLineBreaks: 1,\n        blockTransform: function blockTransform(str) {\n          return prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\\n/g, spacing);\n        }\n      });\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  builder.closeBlock({\n    trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n  });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList(elem, walk, builder, formatOptions) {\n  var prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, function () {\n    return prefix;\n  });\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList(elem, walk, builder, formatOptions) {\n  var nextIndex = Number(elem.attribs.start || '1');\n  var indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  var nextPrefixCallback = function nextPrefixCallback() {\n    return ' ' + indexFunction(nextIndex++) + '. ';\n  };\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction() {\n  var olType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1';\n  switch (olType) {\n    case 'a':\n      return function (i) {\n        return numberToLetterSequence(i, 'a');\n      };\n    case 'A':\n      return function (i) {\n        return numberToLetterSequence(i, 'A');\n      };\n    case 'i':\n      return function (i) {\n        return numberToRoman(i).toLowerCase();\n      };\n    case 'I':\n      return function (i) {\n        return numberToRoman(i);\n      };\n    case '1':\n    default:\n      return function (i) {\n        return i.toString();\n      };\n  }\n}\nfunction isDataTable(attr, tables) {\n  if (tables === true) {\n    return true;\n  }\n  if (!attr) {\n    return false;\n  }\n  var _splitClassesAndIds = splitClassesAndIds(tables),\n    classes = _splitClassesAndIds.classes,\n    ids = _splitClassesAndIds.ids;\n  var attrClasses = (attr['class'] || '').split(' ');\n  var attrIds = (attr['id'] || '').split(' ');\n  return attrClasses.some(function (x) {\n    return classes.includes(x);\n  }) || attrIds.some(function (x) {\n    return ids.includes(x);\n  });\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable(elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable(elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    colSpacing: formatOptions.colSpacing,\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    rowSpacing: formatOptions.rowSpacing,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n  function formatCell(cellNode) {\n    var colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    var rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({\n      maxColumnWidth: formatOptions.maxColumnWidth\n    });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({\n      colspan: colspan,\n      rowspan: rowspan\n    });\n  }\n  function walkTable(elem) {\n    if (elem.type !== 'tag') {\n      return;\n    }\n    var formatHeaderCell = formatOptions.uppercaseHeaderCells ? function (cellNode) {\n      builder.pushWordTransform(function (str) {\n        return str.toUpperCase();\n      });\n      formatCell(cellNode);\n      builder.popWordTransform();\n    } : formatCell;\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n      case 'tr':\n        {\n          builder.openTableRow();\n          var _iterator2 = _createForOfIteratorHelper(elem.children),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var childOfTr = _step2.value;\n              if (childOfTr.type !== 'tag') {\n                continue;\n              }\n              switch (childOfTr.name) {\n                case 'th':\n                  {\n                    formatHeaderCell(childOfTr);\n                    break;\n                  }\n                case 'td':\n                  {\n                    formatCell(childOfTr);\n                    break;\n                  }\n                default:\n                // do nothing\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          builder.closeTableRow();\n          break;\n        }\n      default:\n      // do nothing\n    }\n  }\n}\n\nmodule.exports = {\n  anchor: formatAnchor,\n  block: formatBlock,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  inline: formatInline,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  skip: formatSkip,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n};","map":{"version":3,"names":["he","require","get","numberToLetterSequence","numberToRoman","splitClassesAndIds","trimCharacter","formatSkip","elem","walk","builder","formatOptions","formatInline","children","formatBlock","openBlock","leadingLineBreaks","closeBlock","trailingLineBreaks","formatLineBreak","addLineBreak","formatWbr","addWordBreakOpportunity","formatHorizontalLine","addInline","repeat","length","options","wordwrap","formatParagraph","formatPre","isPre","formatHeading","uppercase","pushWordTransform","str","toUpperCase","popWordTransform","formatBlockquote","reservedLineLength","blockTransform","trimEmptyLines","split","map","line","join","formatImage","attribs","alt","decode","decodeOptions","src","baseUrl","indexOf","text","formatAnchor","getHref","ignoreHref","href","replace","noAnchorUrl","hideSameLink","hideLinkHrefIfSameAsText","noLinkBrackets","noWordTransform","formatList","nextPrefixCallback","isNestedList","maxPrefixLength","listItems","filter","child","type","test","data","name","node","prefix","trimStart","spacing","formatUnorderedList","itemPrefix","formatOrderedList","nextIndex","Number","start","indexFunction","getOrderedListIndexFunction","olType","i","toLowerCase","toString","isDataTable","attr","tables","classes","ids","attrClasses","attrIds","some","x","includes","formatTable","formatDataTable","openTable","forEach","walkTable","closeTable","colSpacing","rowSpacing","formatCell","cellNode","colspan","rowspan","openTableCell","maxColumnWidth","closeTableCell","formatHeaderCell","uppercaseHeaderCells","openTableRow","childOfTr","closeTableRow","module","exports","anchor","block","blockquote","dataTable","heading","horizontalLine","image","inline","lineBreak","orderedList","paragraph","pre","skip","table","unorderedList","wbr"],"sources":["C:/Users/Tapasya/Desktop/SAHIL VIT/chatapp/node_modules/html-to-text/lib/formatter.js"],"sourcesContent":["const he = require('he');\n\nconst { get, numberToLetterSequence, numberToRoman, splitClassesAndIds, trimCharacter } = require('./helper');\n\n// eslint-disable-next-line import/no-unassigned-import\nrequire('./typedefs');\n\n\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */\nfunction formatSkip (elem, walk, builder, formatOptions) {\n  /* do nothing */\n}\n\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */\nfunction formatInline (elem, walk, builder, formatOptions) {\n  walk(elem.children, builder);\n}\n\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */\nfunction formatBlock (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });\n}\n\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */\nfunction formatLineBreak (elem, walk, builder, formatOptions) {\n  builder.addLineBreak();\n}\n\n/**\n * Process a `wbk` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */\nfunction formatWbr (elem, walk, builder, formatOptions) {\n  builder.addWordBreakOpportunity();\n}\n\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */\nfunction formatHorizontalLine (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */\nfunction formatParagraph (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */\nfunction formatPre (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    isPre: true,\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */\nfunction formatHeading (elem, walk, builder, formatOptions) {\n  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });\n  if (formatOptions.uppercase !== false) {\n    builder.pushWordTransform(str => str.toUpperCase());\n    walk(elem.children, builder);\n    builder.popWordTransform();\n  } else {\n    walk(elem.children, builder);\n  }\n  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });\n}\n\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */\nfunction formatBlockquote (elem, walk, builder, formatOptions) {\n  builder.openBlock({\n    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n    reservedLineLength: 2\n  });\n  walk(elem.children, builder);\n  builder.closeBlock({\n    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\\n') : str)\n      .split('\\n')\n      .map(line => '> ' + line)\n      .join('\\n')\n  });\n}\n\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */\nfunction formatImage (elem, walk, builder, formatOptions) {\n  const attribs = elem.attribs || {};\n  const alt = (attribs.alt)\n    ? he.decode(attribs.alt, builder.options.decodeOptions)\n    : '';\n  const src = (!attribs.src)\n    ? ''\n    : (formatOptions.baseUrl && attribs.src.indexOf('/') === 0)\n      ? formatOptions.baseUrl + attribs.src\n      : attribs.src;\n  const text = (!src)\n    ? alt\n    : (!alt)\n      ? '[' + src + ']'\n      : alt + ' [' + src + ']';\n\n  builder.addInline(text);\n}\n\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */\nfunction formatAnchor (elem, walk, builder, formatOptions) {\n  function getHref () {\n    if (formatOptions.ignoreHref) { return ''; }\n    if (!elem.attribs || !elem.attribs.href) { return ''; }\n    let href = elem.attribs.href.replace(/^mailto:/, '');\n    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }\n    href = (formatOptions.baseUrl && href[0] === '/')\n      ? formatOptions.baseUrl + href\n      : href;\n    return he.decode(href, builder.options.decodeOptions);\n  }\n  const href = getHref();\n  if (!href) {\n    walk(elem.children, builder);\n  } else {\n    let text = '';\n    builder.pushWordTransform(\n      str => {\n        if (str) { text += str; }\n        return str;\n      }\n    );\n    walk(elem.children, builder);\n    builder.popWordTransform();\n\n    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n    if (!hideSameLink) {\n      builder.addInline(\n        (!text)\n          ? href\n          : (formatOptions.noLinkBrackets)\n            ? ' ' + href\n            : ' [' + href + ']',\n        { noWordTransform: true }\n      );\n    }\n  }\n}\n\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns inreasing index each time it is called.\n */\nfunction formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {\n  const isNestedList = get(elem, ['parent', 'name']) === 'li';\n\n  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n  // so the dumb length comparison is the most robust way to get the correct value.\n  let maxPrefixLength = 0;\n  const listItems = (elem.children || [])\n    // it might be more accuurate to check only for html spaces here, but no significant benefit\n    .filter(child => child.type !== 'text' || !/^\\s*$/.test(child.data))\n    .map(function (child) {\n      if (child.name !== 'li') {\n        return { node: child, prefix: '' };\n      }\n      const prefix = (isNestedList)\n        ? nextPrefixCallback().trimStart()\n        : nextPrefixCallback();\n      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }\n      return { node: child, prefix: prefix };\n    });\n  if (!listItems.length) { return; }\n\n  const reservedLineLength = maxPrefixLength;\n  const spacing = '\\n' + ' '.repeat(reservedLineLength);\n  builder.openBlock({ leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2) });\n  for (const { node, prefix } of listItems) {\n    builder.openBlock({\n      leadingLineBreaks: 1,\n      reservedLineLength: reservedLineLength\n    });\n    walk([node], builder);\n    builder.closeBlock({\n      trailingLineBreaks: 1,\n      blockTransform: str => prefix + ' '.repeat(reservedLineLength - prefix.length) + str.replace(/\\n/g, spacing)\n    });\n  }\n  builder.closeBlock({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });\n}\n\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatUnorderedList (elem, walk, builder, formatOptions) {\n  const prefix = formatOptions.itemPrefix || ' * ';\n  return formatList(elem, walk, builder, formatOptions, () => prefix);\n}\n\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */\nfunction formatOrderedList (elem, walk, builder, formatOptions) {\n  let nextIndex = Number(elem.attribs.start || '1');\n  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';\n  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */\nfunction getOrderedListIndexFunction (olType = '1') {\n  switch (olType) {\n    case 'a': return (i) => numberToLetterSequence(i, 'a');\n    case 'A': return (i) => numberToLetterSequence(i, 'A');\n    case 'i': return (i) => numberToRoman(i).toLowerCase();\n    case 'I': return (i) => numberToRoman(i);\n    case '1':\n    default: return (i) => (i).toString();\n  }\n}\n\nfunction isDataTable (attr, tables) {\n  if (tables === true) { return true; }\n  if (!attr) { return false; }\n\n  const { classes, ids } = splitClassesAndIds(tables);\n  const attrClasses = (attr['class'] || '').split(' ');\n  const attrIds = (attr['id'] || '').split(' ');\n\n  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));\n}\n\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */\nfunction formatTable (elem, walk, builder, formatOptions) {\n  return isDataTable(elem.attribs, builder.options.tables)\n    ? formatDataTable(elem, walk, builder, formatOptions)\n    : formatBlock(elem, walk, builder, formatOptions);\n}\n\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */\nfunction formatDataTable (elem, walk, builder, formatOptions) {\n  builder.openTable();\n  elem.children.forEach(walkTable);\n  builder.closeTable({\n    colSpacing: formatOptions.colSpacing,\n    leadingLineBreaks: formatOptions.leadingLineBreaks,\n    rowSpacing: formatOptions.rowSpacing,\n    trailingLineBreaks: formatOptions.trailingLineBreaks\n  });\n\n  function formatCell (cellNode) {\n    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;\n    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;\n    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });\n    walk(cellNode.children, builder);\n    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });\n  }\n\n  function walkTable (elem) {\n    if (elem.type !== 'tag') { return; }\n\n    const formatHeaderCell = (formatOptions.uppercaseHeaderCells)\n      ? (cellNode) => {\n        builder.pushWordTransform(str => str.toUpperCase());\n        formatCell(cellNode);\n        builder.popWordTransform();\n      }\n      : formatCell;\n\n    switch (elem.name) {\n      case 'thead':\n      case 'tbody':\n      case 'tfoot':\n      case 'center':\n        elem.children.forEach(walkTable);\n        return;\n\n      case 'tr': {\n        builder.openTableRow();\n        for (const childOfTr of elem.children) {\n          if (childOfTr.type !== 'tag') { continue; }\n          switch (childOfTr.name) {\n            case 'th': {\n              formatHeaderCell(childOfTr);\n              break;\n            }\n            case 'td': {\n              formatCell(childOfTr);\n              break;\n            }\n            default:\n              // do nothing\n          }\n        }\n        builder.closeTableRow();\n        break;\n      }\n\n      default:\n        // do nothing\n    }\n  }\n}\n\nmodule.exports = {\n  anchor: formatAnchor,\n  block: formatBlock,\n  blockquote: formatBlockquote,\n  dataTable: formatDataTable,\n  heading: formatHeading,\n  horizontalLine: formatHorizontalLine,\n  image: formatImage,\n  inline: formatInline,\n  lineBreak: formatLineBreak,\n  orderedList: formatOrderedList,\n  paragraph: formatParagraph,\n  pre: formatPre,\n  skip: formatSkip,\n  table: formatTable,\n  unorderedList: formatUnorderedList,\n  wbr: formatWbr\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}